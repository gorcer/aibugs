Роль:
Ты профессиональный разработчик на Node.js.
Ты предварительно проектируешь архитектуру перед кодированием.
Следуешь принципам SOLID, делаешь под каждый логический модуль отдельный файл.
Избегаешь сложного запутанного монолита, предпочитаешь делить логику на сервисы.
Делаешь удобный масштабируемый продукт.

Серверная часть игры AiBugs на node.js express.js

Сущности:
1) Игровой мир (World)
- ширина=100
- высота=100
- время принятия решения(в секундах) = 10
- timestamp окончания хода
- feed_count -  количество еды на карте =100(в единицах)
- feed_amount - объем еды в каллориях =1000000
- subtract_feed_per_turn уменьшение выделяемого числа калорий за ход = 1

2) Жук
(- атрибут = дефолтное значение (описание))
- name
- x
- y
- angle = 0 (текущий угол поворота, может меняться с шагом 90 градусов)
- current_energy=10000 (текущая энергия в калориях)
- current_health=100 (здоровье)
- faction (фракция, пока 1)
- max_speed = 1 (скорость перемещения клеток за ход)
- rotate_speed=90 (скорость перемещения, градусов за ход)
- max_energy = 10000 (максимум энергии)
- energy_consumption_per_cell = 10 (сколько энергии тратит на перемещение на 1 клетку)
- energy_consumption_per_degree = 0.1 (сколькол энергии тратиться на поворот на 1 градус)
- energy_consumption_per_turn = 1 (затраты энергии дефолтные за существование на карте за ход)
- speed_multiply_on_low_energy = 0.3 (мультипликатор скорости и поворота на нулевой энергии)
- max_health = 100
- health_subtract_on_low_energy_per_turn=1 (с какой скоростью отнимается здоровье если нулевая энергия)
- health_increase_on_high_energy_per_turn=1 (с какой скоростью восстанавливается здоровье если энергии много)
- energy_high_amount=70 (процент энергии достаточный чтобы считалось что её много)
- energy_low_amount = 10 (процент энергии ниже которого считается что энергии недостаточно)
- attack=1 (сколько отнимает здоровья у врага жук когда кусает его)
- defence=0 (какой процент здоровья сохраняет жук в случае укуса)
- feed_speed = 1 (с какой скоростью восстанавливает энергию когда ест)
- visible_range (дальность видимости, на сколько клеток видит жук)
- age - возраст жука в ходах
- memory_limit = 10 - сколько шагов помнит жук
- is_live (живой пока здоровье >0)
- is_visible (видим пока его не съели)
- weight = 100 (вес жука, отнимается вместе со здоровьем при укусах врагов)
- weight_increase_on_high_energy_per_turn=1 (с какой скоростью восстанавливается вес если энергии много)

3) Еда
- x
- y
- type (1 - Обыная еда, 2 - мертвый жук)
- amount (количество еды)

4) История
- объект (жук/еда)
- действие
- payload



Ендпоинты:
1) addUnit (name, x, y, angle) - добавление нового жука на карту
В заданных координатах появляется жук.
Жук занимает одну клетку.
Проверка на занятость клетки и попадение в координаты мира.
Ответ: unit.uid

2) watch (unitUid) - получение информации что видит жук в данный момент.
От текущих координат строим вектор в направлении bug.angle на длину bug.visible_range.
На каждом шаге увеличиваем перпендикулярно к вектору область видимости по 1 единице на каждый шаг.
Получаем матрицу в виде треугольника.
Пример: жук (visible_range=3) в координатах x=10,y=10 смотрит вниз тогда матрица которую он видит будет такой:
10,11
9,12 10,12, 11,12
8,13, 9, 13, 10,13 11,13 14,13
По полученным координатам заполняем наличие объектов на карте.
Возможные варианты:
0 - ничего
1 - еда
2 - жук
Формат ответа:
- turnN - номер хода
- viewMap - массив с тем что видит жук
Доставать последний элемент из памяти, в нем и будет храниться.

3) action(initTourN, actionId) - выполнить действие
Список возможных действий:
1 - move (движение вперед на клетку)
2 - rotate (angle) (поворот, варианты -90, +90)
3 - bite (кусать другого жука или еду)
initTourN - передается для учета в какой ход планировал походить игрок, если запрос пришел позднее, на следующий ход например, то он выполняется, но считается что игрок не успел походить в статистике.
Если action пришел когда закончился "timestamp окончания хода" и сейчас идет расчет, то он добавляется в массив на следующий ход.

4) feel - получить ощущения
Возможные варинты:
1) pain = angle|null - указывает боль на определенном углу от направления bug.angle.
Например если 90, это означает что справа от направления взгляда жука боль.
2) energy = low, normal, high (показатель энергии)
3) health = low, normal, high (показатель здоровья)
4) currentAction = текущее выполняемое действие
Формат ответа:
- turnN
- feeling - массив, наприме: [ [pain:90], [pain:-90], [energy:low], [health: high], [currentAction: move] ]
Доставать последний элемент из памяти, в нем и будет храниться.

5) memory - получить воспоминания о прошедших шагах.
Нужно если жук не запрашивал свое состояние несколько ходов и нужно понять что с ним происходило.
Формат:
memory: [
tournN
action [initTourN, action, payload],
viewMap - array
feeling - array
]
Для каждого жука хранить не более  memory_limit воспоминаний.


Запуск сервера:
Генерация карты размером ширина х высота клеток.
Раскидывание случайным образом еды feed_count элементов.
Распределение всего объема feed_amount на feed_count в случайном объеме. Сумарный объем еды на карте не должен превышать feed_amount.


Ход игры:
Для каждого жука:
1) Выполняются действия жуков в порядке их поступления в очередь
- move - на основании времени начала выполнения действия и скорости жука определяется сколько ходов ему нужно чтобы преодолеть клетку.
Если нужный ход настал, то жук перемещается. Если на пути жука появился предмет, то действие заканчивается.
При перемещении рассчитывается сколько энергии потребяется на однуклетку  и если клетка пройдена, то списывается из энергии energy_consumption_per_cell.
Учеть мультипликатор скорости если низкая энергия.

- rotate - изменить угол поворота жука. Отнимается speed_multiply_on_low_energy за каждый повернутый градус.
Учеть мультипликатор скорости если низкая энергия.

- bite - укусить. В зависимости от того кто находится перед жуком возможны варианты:
1. пустота - ничего не происходит
2. еда  - у сущности еды уменьшается amount на bug.feed_speed, у жука увеличивается current_energy на feed_speed
3. другой жук - у другого жука отнимается вес и здоровье на bug.attack*bug.feed_speed, записывается в memory боль и с какой стороны; у нашего жука увеличивается current_energy
4. не съедобный объект - ничего не происходит

2) Расчитывается потребление энергии жуком energy_consumption_per_turn
3) Расчитывается что видит каждый жук, матрица сохраняется в memory
4) Расчитывается что чувствует каждый жук, сохраняется в память
5) Расчитывается какая еда была съедена,
элементы с feed.amount=0 удаляются с карты, уменьшается world.feed_amount на subtract_feed_per_turn и добавляются новые элементы еды с учетом уменьшенного количества. По ним распределяется amount так чтобы не превысить world.feed_amount
7) Если какой-то жук умер (weight=0 or health=0) то он превращается в еду с amount=weight. Если weight=0 то жук исчезает, его съели.

8) Расчитывается сколько жуков успело походить за прошлый ход, если меньше 100% то увеличиваем время на принятие решения на 10%.
Максимальное время принятия решения - 30 секунд. Если 100% жуков успели прислать действие, либо уже имеют незаконченные действия, то сокращаем время принятия решения на 10%.
Минимальное время принятия решения 1 сек.
Начальное время принятия решения - 10 секунд.

